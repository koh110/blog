<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  <link rel="icon" type="image/svg+xml" href="/favicon.jpg">
  <title>TypeORM v0.3へのバージョンアップ方法</title>
  <meta name="description" content="TypeORMのアップデート
NestJSで利用しているTypeORMのバージョンをv0.2からv0.3に引き上げた。
v0.3ではかなりの破壊的変更が入っていたため、結構大変な作業だったのでやり方と方針を備忘録にまとめる。
TypeORM...">
  <meta property="og:title" content="TypeORM v0.3へのバージョンアップ方法">
  <meta property="og:image" content="https://blog.koh.dev/ogimg/2022-11-17-typeorm.png">
  <meta property="og:url" content="https://blog.koh.dev">
  <meta name="og:description" content="TypeORMのアップデート
NestJSで利用しているTypeORMのバージョンをv0.2からv0.3に引き上げた。
v0.3ではかなりの破壊的変更が入っていたため、結構大変な作業だったのでやり方と方針を備忘録にまとめる。
TypeORM...">
  <meta property="og:type" content="artcle">
  <meta property="og:site_name" content="kohsweblog">
  <meta name="twitter:card" content="summary_large_image">
  <!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNBJ1CBWWX"></script>

<link rel="stylesheet" href="/_astro/_post_.c53320ea.css" />
<link rel="stylesheet" href="/_astro/_post_.4accc94d.css" /><script type="module">window.dataLayer=window.dataLayer||[];function a(){dataLayer.push(arguments)}a("js",new Date);a("config","G-ZNBJ1CBWWX");
</script><link rel="stylesheet" href="/_astro/MarkdownLayout.astro_astro_type_style_index_0_lang.598eec69.css" /></head>
<body>
  
  
  <main class="astro-5GRSW2HI">
    <header class="astro-5GRSW2HI">
      <h3 class="astro-5GRSW2HI"><a href="/" class="astro-5GRSW2HI">kohsweblog</a></h3>
    </header>
    <h1 class="astro-5GRSW2HI">TypeORM v0.3へのバージョンアップ方法</h1>
    <time class="astro-5GRSW2HI">2022-11-17</time>
    <div class="social astro-5GRSW2HI">
      <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-size="large" data-via="koh110" data-show-count="false">Tweet</a>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
      <a href="https://b.hatena.ne.jp/entry/" class="hatena-bookmark-button astro-5GRSW2HI" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" data-hatena-bookmark-height="28" title="このエントリーをはてなブックマークに追加">
        <img src="https://b.st-hatena.com/images/v4/public/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" class="astro-5GRSW2HI">
      </a>
    </div>
    <div class="og astro-5GRSW2HI">
      <div class="image astro-5GRSW2HI">
        <img style="max-width:100%" src="/ogimg/2022-11-17-typeorm.png" alt="og image" class="astro-5GRSW2HI">
        
      </div>
    </div>
    
  <article class="astro-XSCT23V3">
  <h1 id="typeormのアップデート">TypeORMのアップデート</h1>
<p>NestJSで利用しているTypeORMのバージョンをv0.2からv0.3に引き上げた。
v0.3ではかなりの破壊的変更が入っていたため、結構大変な作業だったのでやり方と方針を備忘録にまとめる。</p>
<p><a href="https://github.com/typeorm/typeorm/blob/master/CHANGELOG.md#030-2022-03-17">TypeORMリリースノート</a></p>
<p>個人的におおきな破壊的変更は次の3つ</p>
<ol>
<li>データベースのつなぎ方がConnectionからDataSourceという仕組みに変更</li>
<li>CustomRepositoryの定義方法がclassからobjectに変更</li>
<li>findのwhereが <code>{ id: undefined }</code> の時の返却値が、空配列から全件取得に変更</li>
</ol>
<h2 id="connectionからdatasourceに変更">ConnectionからDataSourceに変更</h2>
<p>データベースへの接続がDataSourceオブジェクトを生成する形に変更された。
また<code>ormconfig.js</code>ファイルから自動で読み込む仕組みがなくなったため、configファイルを直接importで指定する必要がある。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> ormconfig </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'./ormconfig'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">dataSource</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">DataSource</span><span style="color: #E1E4E8">(ormconfig);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">await</span><span style="color: #E1E4E8"> dataSource.</span><span style="color: #B392F0">connect</span><span style="color: #E1E4E8">();</span></span></code></pre>
<p>configファイルを直接指定する形式になったので、JavaScript(<code>ormconfig.js</code>)からTypeScript(<code>ormconfig.ts</code>)に置き換えた。</p>
<p>NestJSのTypeORMモジュールではDataSourceオブジェクトの生成からconnectまでを内部でやってくれている。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// app.module.ts</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> ormconfig </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'./ormconfig'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">@</span><span style="color: #B392F0">Module</span><span style="color: #E1E4E8">({</span></span>
<span class="line"><span style="color: #E1E4E8">  imports: [</span></span>
<span class="line"><span style="color: #E1E4E8">    TypeOrmModule.</span><span style="color: #B392F0">forRoot</span><span style="color: #E1E4E8">(config), </span><span style="color: #6A737D">// ここで直接ormconfigを指定する形に</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">...</span></span>
<span class="line"><span style="color: #E1E4E8">  ],</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span></code></pre>
<h2 id="customrepositoryの定義方法がobjectに変更">CustomRepositoryの定義方法がobjectに変更</h2>
<p>元々のCustomRepositoryの定義方法はclassに対してEntityRepositoryデコレータでEntityを紐づける形。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { EntityRepository, Repository } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'typeorm'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { BarEntity } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'./bar.entity'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">@</span><span style="color: #B392F0">EntityRepository</span><span style="color: #E1E4E8">(BarEntity)</span></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">BarRepository</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">extends</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Repository</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">BarEntity</span><span style="color: #E1E4E8">> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">async</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">fineBarWithQuery</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">query</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">...</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>これがdataSourceオブジェクトから生成する形に変更になった。</p>
<p><code>dataSource.getRepository(Entity).extends({ ... })</code></p>
<p>この書き換えで課題になるのは「dataSoureオブジェクトをどうやってCustomRepositoryファイルに渡すか」という点。</p>
<p>repositoryファイルの中で<code>new DataSource()</code>するのはコネクションを多重接続してしまうのでなし。</p>
<p>次に考えられるのは別ファイルで<code>export const dataSource = new DataSource()</code>したものをimportする方法。
しかしこれをやるとNestJS側で生成しているコネクションと2重になってしまった時にトランザクションがどのように動くか分からなかった。</p>
<p>そのため、NestJSが生成したdataSourceをCustomRepositoryに渡す必要がある。
なのでFactoryを作成して、NestJSにはproviderで直接指定する形を採用することにした。</p>
<p>先ほどのサンプルを書き換えると次のような形になる</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { DataSource } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'typeorm'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { getDataSourceToken, getCustomRepositoryToken } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'@nestjs/typeorm'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { FactoryProvider } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'@nestjs/common'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { BarEntity } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'./bar.entity'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// classの代わりの型定義</span></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">type</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">BarRepositoryType</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">ReturnType</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #F97583">typeof</span><span style="color: #E1E4E8"> BarRepositoryFactory>;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// dataSourceを受け取るためのfactory</span></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">BarRepositoryFactory</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">dataSource</span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">DataSource</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> dataSource.</span><span style="color: #B392F0">getRepository</span><span style="color: #E1E4E8">(BarEntity).</span><span style="color: #B392F0">extend</span><span style="color: #E1E4E8">({</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">async</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">fineBarWithQuery</span><span style="color: #E1E4E8">(</span><span style="color: #FFAB70">query</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      </span><span style="color: #F97583">...</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">  });</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// NestJSに注入するためProvider</span></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">BarRepositoryProvider</span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">FactoryProvider</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">BarRepositoryType</span><span style="color: #E1E4E8">> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  provide: </span><span style="color: #B392F0">getCustomRepositoryToken</span><span style="color: #E1E4E8">(BarRepositoryFactory),</span></span>
<span class="line"><span style="color: #E1E4E8">  useFactory: BarRepositoryFactory,</span></span>
<span class="line"><span style="color: #E1E4E8">  inject: [</span><span style="color: #B392F0">getDataSourceToken</span><span style="color: #E1E4E8">()],</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>NestJSがわは元々<code>TypeOrmModule.forFeature([...])</code>の引数にCustomRepositoryのクラスを指定することで自動的にDIなどができた。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { TypeOrmModule } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'@nestjs/typeorm'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { BarRepository } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'./bar.repository'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">@</span><span style="color: #B392F0">Module</span><span style="color: #E1E4E8">({</span></span>
<span class="line"><span style="color: #E1E4E8">  imports: [</span></span>
<span class="line"><span style="color: #E1E4E8">    TypeOrmModule.</span><span style="color: #B392F0">forFeature</span><span style="color: #E1E4E8">([BarRepository]),</span></span>
<span class="line"><span style="color: #E1E4E8">  ],</span></span>
<span class="line"><span style="color: #E1E4E8">  providers: [FooService]</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">FooModule</span><span style="color: #E1E4E8"> {}</span></span></code></pre>
<p>今回のアップデートでforFeatureへの指定ができなくなってしまったため、providersで直接指定する形に変更する。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { TypeOrmModule, getDataSourceToken } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'@nestjs/typeorm'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { BarRepositoryProvider } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'./bar.repository'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">@</span><span style="color: #B392F0">Module</span><span style="color: #E1E4E8">({</span></span>
<span class="line"><span style="color: #E1E4E8">  imports: [</span></span>
<span class="line"><span style="color: #E1E4E8">    TypeOrmModule.</span><span style="color: #B392F0">forFeature</span><span style="color: #E1E4E8">([])</span></span>
<span class="line"><span style="color: #E1E4E8">  ],</span></span>
<span class="line"><span style="color: #E1E4E8">  providers: [</span></span>
<span class="line"><span style="color: #E1E4E8">    FooService,</span></span>
<span class="line"><span style="color: #E1E4E8">    BarRepositoryProvider</span></span>
<span class="line"><span style="color: #E1E4E8">  ]</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">FooModule</span><span style="color: #E1E4E8"> {}</span></span></code></pre>
<p>Providerに直接指定するためには、どのインスタンスが同一のものかを判定するためにprovideに一意な文字列が必要になる。
TypeORMモジュールのコードを読んでみると、classの頃は<code>class.name</code>を内部的に参照していた。</p>
<p>同様にFactoryのnameを一意な値として利用すればよいかと考えたが、コードを読んでいたらたまたまTypeORM側に<code>getCustomRepositoryToken</code>というutilメソッドが用意されているのを発見したのでそちらを利用する形にした。</p>
<p><a href="https://github.com/nestjs/typeorm/blob/9432329a7c5da4e5866af3b8ed2ef712c909e931/lib/common/typeorm.utils.ts#L61-L66">getCustomRepositoryToken</a></p>
<p>動作だけなら<code>Factory.name</code>や一意な文字列を与えればよいが、今後自分以外がいじる際にルールを守れるかという点が気になったため、意図を明示できる関数を利用する方向にした。</p>
<p>NestJSの内部で生成されたDataSourceをFactoryの引数に与えるためには<code>getDataSourceToken</code>を利用する。</p>
<p><a href="https://github.com/nestjs/typeorm/blob/9432329a7c5da4e5866af3b8ed2ef712c909e931/lib/common/typeorm.utils.ts#L74-L87">getDataSourceToken</a></p>
<p><code>getDataSourceToken</code>をinjectに与える事で、NestJSのセットアップ時に<code>BarRepositoryFactory</code>に内部で生成されたdataSourceの参照が注入される。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// NestJSに注入するためProvider</span></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">BarRepositoryProvider</span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">FactoryProvider</span><span style="color: #E1E4E8">&#x3C;</span><span style="color: #B392F0">BarRepositoryType</span><span style="color: #E1E4E8">> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  provide: </span><span style="color: #B392F0">getCustomRepositoryToken</span><span style="color: #E1E4E8">(BarRepositoryFactory),</span></span>
<span class="line"><span style="color: #E1E4E8">  useFactory: BarRepositoryFactory,</span></span>
<span class="line"><span style="color: #E1E4E8">  inject: [</span><span style="color: #B392F0">getDataSourceToken</span><span style="color: #E1E4E8">()],</span></span>
<span class="line"><span style="color: #E1E4E8">};</span></span></code></pre>
<p>最後にCustomRepositoryを使ってたServiceの改修をする。</p>
<p>元々はimportしたclassをそのままコンストラクタに指定してするとNestJSが判断してDIしてくれていた。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { Injectable } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'@nestjs/common'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { BarRepository } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'./bar.repository'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">FooService</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">constructor</span><span style="color: #E1E4E8">(</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">private</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">repository</span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">BarRepository</span></span>
<span class="line"><span style="color: #E1E4E8">  ) {}</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>これを明示的にDI指定するためにInjectアノテーションに直接<code>getCustomRepositoryToken</code>とFactoryから生成した文字列を与える。
これでprovidersの中で指定したprovideと文字列が一致するのでDIされるようになる。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { Injectable, Inject } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'@nestjs/common'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> { getCustomRepositoryToken } </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'@nestjs/typeorm'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  BarRepositoryFactory,</span></span>
<span class="line"><span style="color: #E1E4E8">  BarRepositoryType</span></span>
<span class="line"><span style="color: #E1E4E8">} </span><span style="color: #F97583">from</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'./bar.repository'</span><span style="color: #E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">export</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">class</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">FooService</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">constructor</span><span style="color: #E1E4E8">(</span></span>
<span class="line"><span style="color: #E1E4E8">    @</span><span style="color: #B392F0">Inject</span><span style="color: #E1E4E8">(BarRepositoryInjectName)</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">private</span><span style="color: #E1E4E8"> </span><span style="color: #FFAB70">repository</span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">BarRepositoryType</span><span style="color: #E1E4E8"> </span><span style="color: #6A737D">// classじゃなくなったのでFactoryのReturnTypeで返ってきたオブジェクトを型にする</span></span>
<span class="line"><span style="color: #E1E4E8">  ) {}</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">repo</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">getManager</span><span style="color: #E1E4E8">().</span><span style="color: #B392F0">getCustomRepository</span><span style="color: #E1E4E8">(BarRepository);</span></span>
<span class="line"><span style="color: #F97583">---</span></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">repo</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> dataSource.manager.</span><span style="color: #B392F0">withRepository</span><span style="color: #E1E4E8">(BarRepository);</span></span></code></pre>
<h2 id="findのwhere条件を変更">findのwhere条件を変更</h2>
<p>動的にfind条件を変更するメソッドで <code>{ id: undefined }</code> になるパターンがあった。</p>
<p>この時、v0.2では空配列（=該当なし）として扱われていたが、v0.3ではデータ全件（=条件の指定なし）にさらっと変更されていた。（ドキュメントに記載見当たらず）</p>
<p>まるきり逆の挙動になってる上に、全件取得という結構な負荷が出そうな変更がさらっとされていてかなり驚いた。</p>
<p>テスト書いてあって助かった。</p>
<h1 id="感想">感想</h1>
<p>個人的にCustomRepositoryが一番大きな破壊的変更だった。</p>
<p>変更後の方がclassもアノテーションを用いずに個人的にはきれいで好み。
だが、なぜこのタイミングでこれだけ設計全体に影響を与える大きな破壊的変更を加えたのかは疑問を持った。</p>
<p><a href="https://github.com/typeorm/typeorm/issues/9013">issue</a>でも同様の意見があがっていたが、なぜという疑問に回答はなかった。</p>
<p>v0のアプリケーションなので破壊的変更が加わるのは仕方ないとは思うが、もう少しmigrationのコストが低くないと脱落する人が出てきそうという感想をもった。</p>
<p>NestJSではTypeORMが標準的な扱いを受けているところもあるので、今後もカジュアルに破壊的変更がされるとなると少し採用に慎重な姿勢を持ってしまいそうである。</p>
</article>

    <hr class="astro-5GRSW2HI">
    <ul class="post-selector astro-5GRSW2HI">
     <li class="astro-5GRSW2HI"><a rel="prev" href="/2022-07-02-jest-speedup" class="astro-5GRSW2HI"> ← jestでDBありのテストを高速化する</a></li>
     <li class="astro-5GRSW2HI"><a rel="next" href="/2023-01-26-nodejs-book" class="astro-5GRSW2HI">実践Node.js入門という本が出ます → </a></li>
    </ul>
    <footer class="astro-SZ7XMLTE">
  © 2023,
  <a href="https://koh.dev" target="_blank" class="astro-SZ7XMLTE">
    kohsweb
  </a>
</footer>
  </main>

  <script src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript" async></script>
</body></html>