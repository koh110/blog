<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  <link rel="icon" type="image/svg+xml" href="/favicon.jpg">
  <title>0から始めるNode.jsパフォーマンスチューニング</title>
  <meta name="description" content="近年の Node.js は API のサーバとしてはもちろん、Nuxt.js や Next.js といった SSR や BFF などフロントエンドのためのバックエンド言語としての人気が高まっています。
フロントエンドエンジニアがコンテキスト...">
  <meta property="og:title" content="0から始めるNode.jsパフォーマンスチューニング">
  <meta property="og:image" content="https://blog.koh.dev/ogimg/2020-03-04-nodejs-performance.png">
  <meta property="og:url" content="https://blog.koh.dev">
  <meta name="og:description" content="近年の Node.js は API のサーバとしてはもちろん、Nuxt.js や Next.js といった SSR や BFF などフロントエンドのためのバックエンド言語としての人気が高まっています。
フロントエンドエンジニアがコンテキスト...">
  <meta property="og:type" content="artcle">
  <meta property="og:site_name" content="kohsweblog">
  <meta name="twitter:card" content="summary_large_image">
  <!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNBJ1CBWWX"></script>

<link rel="stylesheet" href="/_astro/_post_.c53320ea.css" />
<link rel="stylesheet" href="/_astro/_post_.4accc94d.css" /><script type="module">window.dataLayer=window.dataLayer||[];function a(){dataLayer.push(arguments)}a("js",new Date);a("config","G-ZNBJ1CBWWX");
</script><link rel="stylesheet" href="/_astro/MarkdownLayout.astro_astro_type_style_index_0_lang.598eec69.css" /></head>
<body>
  
  
  <main class="astro-5GRSW2HI">
    <header class="astro-5GRSW2HI">
      <h3 class="astro-5GRSW2HI"><a href="/" class="astro-5GRSW2HI">kohsweblog</a></h3>
    </header>
    <h1 class="astro-5GRSW2HI">0から始めるNode.jsパフォーマンスチューニング</h1>
    <time class="astro-5GRSW2HI">2020-03-04</time>
    <div class="social astro-5GRSW2HI">
      <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-size="large" data-via="koh110" data-show-count="false">Tweet</a>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
      <a href="https://b.hatena.ne.jp/entry/" class="hatena-bookmark-button astro-5GRSW2HI" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" data-hatena-bookmark-height="28" title="このエントリーをはてなブックマークに追加">
        <img src="https://b.st-hatena.com/images/v4/public/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" class="astro-5GRSW2HI">
      </a>
    </div>
    <div class="og astro-5GRSW2HI">
      <div class="image astro-5GRSW2HI">
        <img style="max-width:100%" src="/ogimg/2020-03-04-nodejs-performance.png" alt="og image" class="astro-5GRSW2HI">
        
      </div>
    </div>
    
  <article class="astro-XSCT23V3">
  <p>近年の Node.js は API のサーバとしてはもちろん、Nuxt.js や Next.js といった SSR や BFF などフロントエンドのためのバックエンド言語としての人気が高まっています。</p>
<p>フロントエンドエンジニアがコンテキストスイッチ少なくバックエンドの整備ができることは非常に大きな利点です。</p>
<p>ですが、フロントエンド（ブラウザ側）とバックエンド（サーバ側）ではパフォーマンスチューニングで見るべき点が大きく違います。</p>
<p>しかし Node.js アプリケーションのパフォーマンスイシューの見つけ方などがまとまっている資料は少ないです。</p>
<p>そこで、本記事ではフロントエンドエンジニアが Node.js でパフォーマンスイシューを見つけ、改善するため自分が普段パフォーマンスチューニングを依頼されているときにみている基礎的なポイトをまとめていきます。</p>
<h1 id="1-計測ステップ">1. 計測ステップ</h1>
<p>Node.js のパフォーマンスチューニングは「性能をよりよくする」というよりは「コードの書き方によって落ちてしまったパフォーマンスを元に戻していく」というイメージになります。どのような API や書き方がパフォーマンスを劣化させているのかを知ることが一番重要です。</p>
<p>そこでまず最初のステップはパフォーマンスの計測です。</p>
<p>何はともあれ計測をしない限り、そのシステムのパフォーマンスが高いのか、もしくは劣化してしまっているのかを判断することはできません。どこがボトルネックなのかを調査するためにも、まずは現状の測定からです。</p>
<p>そのために最初は下記の準備から入ります。</p>
<ul>
<li>本番と同等の挙動をする環境を作る</li>
<li>パフォーマンス計測ツールを入れる</li>
</ul>
<h2 id="本番と同等の挙動をする環境を作る">本番と同等の挙動をする環境を作る</h2>
<p>ステージング環境などすでに自由にいじれる環境がある場合にはこのステップは飛ばすことがあります。</p>
<p>ここで重要なことは <code>NODE_ENV=production</code> で起動する環境を作ることです。</p>
<p>Node.js のモジュールは慣例的に <code>NODE_ENV=production</code> という環境変数が与えられた時に本番環境とみなしているものが多いです。</p>
<p>例えば express は production の時に static files や view contents をキャッシュする仕組みが入っていたり、出力されるログが少なくなったりします。</p>
<p>余談ですが <a href="http://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production">express の本番環境のベストプラクティスドキュメント</a>はとてもよくできていて参考になります。</p>
<p>他にも React の Server Side Rendering に利用する <a href="https://www.npmjs.com/package/react-dom">react-dom-server</a> は <code>NODE_ENV=production</code> の時に<a href="https://github.com/facebook/react/blob/master/packages/react-dom/npm/server.node.js">読み込むファイルが本番用のファイルに切り替わります</a>。
デバッグログや不要なロジックが削除されることにより、大幅にパフォーマンスが変わるので <code>NODE_ENV=production</code> を与えて起動することが本番環境で運用する上で必須条件となります。</p>
<p>具体的にこのステップでやることは、アプリケーションコードから <code>process.env.NODE_ENV</code> が含まれるコードの grep です。</p>
<p>実際のアプリケーションコードはデータベースの接続先や別環境の API の呼び出しなど、環境によって挙動を変えることが多いでしょう。</p>
<p>この環境の切り替えを <code>process.env.NODE_ENV</code> を利用してやっていると、パフォーマンステストで高負荷をかけたものが本番を向いてしまう危険性があります。</p>
<p>こういった環境ごとに変わる挙動を制御する変数はなるべく一箇所に集めるのがパフォーマンステストがしやすいアプリケーションです。デバッグログの出力を本番環境以外では行いたい、という時などに <code>process.env.NODE_ENV</code> を直接アプリケーションコードに if 文で埋め込んでしまうことも多いですが、できる限り避けたほうがよいと思います。</p>
<p>例えば自分はアプリケーションを作るときには config ファイルに env を判断するパラメータを作成し、アプリケーションコードでは必ずこのパラメータにアクセスすると決めて作成しています。</p>
<p>データベースの接続情報なども、環境変数を production にした場合にも開発環境のデータベースにつなげるようにするため、接続モジュールの中に書いてしまうのではなく、どこか一箇所の config ファイルの中に書いておくのがよいと思います。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">// config.js</span></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">production</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> process.env.</span><span style="color: #79B8FF">NODE_ENV</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">===</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'production'</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">module</span><span style="color: #E1E4E8">.</span><span style="color: #79B8FF">exports</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  production,</span></span>
<span class="line"><span style="color: #E1E4E8">  db: {</span></span>
<span class="line"><span style="color: #E1E4E8">    url: production </span><span style="color: #F97583">?</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'mongodb://localhost:27017/prod'</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'mongodb://localhost:27017/dev'</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<h2 id="パフォーマンス計測ツールを入れる">パフォーマンス計測ツールを入れる</h2>
<p>次のステップではパフォーマンスの計測に入ります。ここは各自使い慣れているツールを利用しましょう。
様々なツールがありますが、最近の自分は <a href="https://github.com/tsenart/vegeta">vegeta</a> という計測ツールを利用することが多いです。</p>
<p>パラメータは毎回変わりますが、大体以下のようなコマンドでパフォーマンスを計測します。ログインが必要なページでは header に Cookie を渡して計測します。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">echo</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">"GET http://localhost"</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">|</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">vegeta</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">attack</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-rate=30</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-duration=10s</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-workers=10</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-header</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'Cookie: xxx'</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">|</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">vegeta</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">report</span></span></code></pre>
<p>duration で継続時間を指定して、rate で req/s を調整します。この辺は自分の感覚値ですが <code>rate=30</code> くらいは最低でも食えることを目標にします。</p>
<p>もちろん食えるリクエスト数が増えれば増えるほどよいのですが、パフォーマンスチューニングのためにトリッキーなコードになったりするより、サーバを並列に並べてしまったほうが運用コストが低くなることもあるので、見極めが重要です。</p>
<p>結果の中で一番注目するべきは Latencies と Success です。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">Requests</span><span style="color: #E1E4E8">      [total, </span><span style="color: #9ECBFF">rate,</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">throughput]</span><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">300</span><span style="color: #9ECBFF">,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">30.09</span><span style="color: #9ECBFF">,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">29.75</span></span>
<span class="line"><span style="color: #B392F0">Duration</span><span style="color: #E1E4E8">      [total, </span><span style="color: #9ECBFF">attack,</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">wait]</span><span style="color: #E1E4E8">      </span><span style="color: #79B8FF">10.084217496</span><span style="color: #9ECBFF">s,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">9.969010607</span><span style="color: #9ECBFF">s,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">115.206889</span><span style="color: #9ECBFF">ms</span></span>
<span class="line"><span style="color: #B392F0">Latencies</span><span style="color: #E1E4E8">     [mean, </span><span style="color: #79B8FF">50</span><span style="color: #9ECBFF">,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">95</span><span style="color: #9ECBFF">,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">99</span><span style="color: #9ECBFF">,</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">max]</span><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">118.262733</span><span style="color: #9ECBFF">ms,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">115.071858</span><span style="color: #9ECBFF">ms,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">152.870202</span><span style="color: #9ECBFF">ms,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">274.895501</span><span style="color: #9ECBFF">ms,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">337.340772</span><span style="color: #9ECBFF">ms</span></span>
<span class="line"><span style="color: #B392F0">Bytes</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">In</span><span style="color: #E1E4E8">      [total, </span><span style="color: #9ECBFF">mean]</span><span style="color: #E1E4E8">              </span><span style="color: #79B8FF">5559600</span><span style="color: #9ECBFF">,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">18532.00</span></span>
<span class="line"><span style="color: #B392F0">Bytes</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">Out</span><span style="color: #E1E4E8">     [total, </span><span style="color: #9ECBFF">mean]</span><span style="color: #E1E4E8">              </span><span style="color: #79B8FF">0</span><span style="color: #9ECBFF">,</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0.00</span></span>
<span class="line"><span style="color: #B392F0">Success</span><span style="color: #E1E4E8">       [ratio]                    100.00%</span></span>
<span class="line"><span style="color: #B392F0">Status</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">Codes</span><span style="color: #E1E4E8">  [code:count]               200:300</span></span>
<span class="line"><span style="color: #B392F0">Error</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">Set:</span></span></code></pre>
<p><code>Success</code> はレスポンスがステータスコード 200 で返ってきた率で、ここは 100% を維持する必要があります。</p>
<p>たまに結果がすごくよくなった！と感動していると Success が 0% になっていて、全部エラー処理に入っていたから早かっただけということがあります。</p>
<p>Latencies は平均, 50%, 95%, 99%, 最大のレスポンスタイムが表示されています。ここはシステムによっても目標とする数字は変わりますが、自分は１秒以内を目安としてチューニングを行っていることが多いです。</p>
<h1 id="2-パフォーマンス改善ステップ">2. パフォーマンス改善ステップ</h1>
<p>先のステップでパフォーマンスを計測する準備ができたので次はいよいよ改善に取り掛かります。</p>
<p>自分は重要度順にファイルディスクリプタ > cluster > アプリケーションコードの改善の順番で見ています。</p>
<p>パフォーマンスチューニングというとアプリケーションコードの改善にまず取り掛かかってしまいたいところですが、優先度は一番低く最後の最後で手をつける部分です。表層を改善するより一番下の層を改善するほうが効果がでることが多く、コスト対効果が高いです。</p>
<h2 id="設定確認">設定確認</h2>
<h3 id="linux-編">linux 編</h3>
<p>Linux 上で Node.js を運用するときにまず自分が気にするのは、プロセスが開けるファイルディスクリプタの上限数です。</p>
<p>Node.js は「ノンブロッキング I/O」や「非同期イベント駆動モデル」という特徴を持つ言語です。これに対して Apache などは１つのクライアントのアクセスに１つのプロセスを割り当てるモデルを採用しています。</p>
<p>一時期 C10K 問題が大きく話題に上がったことがありましたが、Node.js や Nginx は「ノンブロッキング I/O」や「非同期イベント駆動モデル」などを採用し、ひとつのプロセスで受けるクライアントの数を増やすことでこの問題に対処できます。</p>
<p>しかしこれらのモデルを採用したことで、逆にひとつのプロセスが同時にオープンするファイルも多くもなっています。それに伴い今度は OS 側が持っているプロセスが開けるファイルオープン数の上限に引っかかってしまう問題に直面することがあります。</p>
<p>そこでまずは <code>ulimit</code> コマンドで設定されている上限を確認します。例えば下記の例ではひとつのプロセスが同時にオープンできるファイル数は 1024 です。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">ulimit</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-n</span></span>
<span class="line"><span style="color: #B392F0">1024</span></span></code></pre>
<p>この数値は Node.js にとって少なすぎます。このままではパフォーマンステストなどで高負荷をかけると <code>Too many open files</code> というエラーが高確率ででます。</p>
<p>自分は systemd を利用してシステムをデーモン化することが多いので <code>LimitNOFILE</code> の設定を忘れないようにしています。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">[Service]</span></span>
<span class="line"><span style="color: #E1E4E8">LimitNOFILE</span><span style="color: #F97583">=</span><span style="color: #79B8FF">65535</span></span>
<span class="line"><span style="color: #79B8FF">...</span></span></code></pre>
<p>パフォーマンステスト中は頻繁にサーバを起動するので bash に起動コマンドを書くことも多いです。その時は bash の先頭で ulimit を使って上限を設定します。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #6A737D">#!/bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">set</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-exuo</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">pipefail</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">ulimit</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-n</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">65535</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">NODE_ENV</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">production</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">node</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">server.js</span></span></code></pre>
<h3 id="nodejs-編">Node.js 編</h3>
<p>Node.js v12 から JSON.parse の高速化や async/await が Promise より高速化するなど、コアコードレベルで様々な高速化が行われています。まずは最新の LTS バージョンにあげることが Node.js アプリケーションでは重要です。<a href="https://speakerdeck.com/ajido/callback-to-promise-and-beyond?slide=14">参考</a></p>
<p>JavaScript は非常に後方互換性の高い言語ということもあり、Node.js はランタイムのバージョンアップでアプリケーションコードが大きく壊れてしまうことは少ないため積極的なアップデートがやりやすく、パフォーマンス対策という意味でも非常に有効な手段です。</p>
<p>Node.js v12 はその他にメモリの割当にも改善が行われました。Node.js v10 では起動時に 1400MB のヒープメモリが必ず確保されていましたが、v12 からは実行環境のメモリサイズに合わせたヒープサイズになるような改修が行われました。（これは近年の Kubernetes や Docker 上で動かす事を考慮した対応になります。）</p>
<p>しかし、これによって合計メモリサイズの低い環境では、今までより確保できるメモリサイズが少なくなってしまうことがあります。具体的には合計メモリサイズが <em>2.8GB 以下</em> の場合は Node.js v12 にバージョンアップすると最大ヒープサイズが半減します。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">docker</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">run</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">--memory=1.5g</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-it</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node:10.19.0-alpine</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-e</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'console.log(Math.round(v8.getHeapStatistics().total_available_size/1024/1024) + " MB")'</span></span>
<span class="line"><span style="color: #B392F0">1450</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">MB</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">docker</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">run</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">--memory=1.5g</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-it</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node:12.16.1-alpine</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-e</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">'console.log(Math.round(v8.getHeapStatistics().total_available_size/1024/1024) + " MB")'</span></span>
<span class="line"><span style="color: #B392F0">789</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">MB</span></span></code></pre>
<p>そのためメモリの少ない環境で起動している場合は <code>--max-old-space-size</code> オプションを使って確保するヒープサイズを調整します。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">NODE_ENV=production</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">--max-old-space-size=8192</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">server.js</span></span></code></pre>
<h2 id="cluster-対応">cluster 対応</h2>
<p>デプロイ先の環境がマルチコア環境の場合は cluster モジュールを使ってマルチコア対応を行います。Node.js はそのままだとマルチコア環境でも１コアしか利用できません。</p>
<p>サンプルコードを下記に示しますが cluster モジュールによるマルチコア対応はとてもシンプルです。たったこれだけで fork 数倍のパフォーマンスを向上できます。非常にコスト対効果の高い対応と言えます。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">cluster</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'cluster'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">http</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'http'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">server</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> http.</span><span style="color: #B392F0">createServer</span><span style="color: #E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">if</span><span style="color: #E1E4E8"> (cluster.isMaster) {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// コア数以内まで fork する</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">; i </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">4</span><span style="color: #E1E4E8">; i</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">    cluster.</span><span style="color: #B392F0">fork</span><span style="color: #E1E4E8">()</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  cluster.</span><span style="color: #B392F0">on</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'exit'</span><span style="color: #E1E4E8">, (</span><span style="color: #FFAB70">worker</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">code</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">signal</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">s</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> signal </span><span style="color: #F97583">||</span><span style="color: #E1E4E8"> code</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">`exit worker #${</span><span style="color: #E1E4E8">worker</span><span style="color: #9ECBFF">.</span><span style="color: #E1E4E8">process</span><span style="color: #9ECBFF">.</span><span style="color: #E1E4E8">pid</span><span style="color: #9ECBFF">} (${</span><span style="color: #E1E4E8">s</span><span style="color: #9ECBFF">})`</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">    cluster.</span><span style="color: #B392F0">fork</span><span style="color: #E1E4E8">()</span></span>
<span class="line"><span style="color: #E1E4E8">  })</span></span>
<span class="line"><span style="color: #E1E4E8">} </span><span style="color: #F97583">else</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  server.</span><span style="color: #B392F0">listen</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">80</span><span style="color: #E1E4E8">, () </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'Listening on'</span><span style="color: #E1E4E8">, server.</span><span style="color: #B392F0">address</span><span style="color: #E1E4E8">())</span></span>
<span class="line"><span style="color: #E1E4E8">  })</span></span>
<span class="line"><span style="color: #E1E4E8">}</span></span></code></pre>
<p>コア数全部 fork する場合は <code>require('os').cpus().length</code> でコア数を取得することもできます。</p>
<p>ここはシステムの運用方針にもよるのですが、コア数全部使い切ってしまうとアプリケーションが CPU 使用率 100% で張り付いてしまった場合に、何もできなくなってしまう危険性もあるのでサーバ内で動いているアプリケーションの数などサーバの構成によって調整してください。</p>
<h2 id="プロファイリング">プロファイリング</h2>
<p>ここまできたらついにアプリケーションコードの改善に着手します。</p>
<h3 id="nodejs-編-1">Node.js 編</h3>
<p>Node.js には CPU のプロファイリングを行える <code>--prof</code> という起動オプションがあります。<a href="https://nodejs.org/es/docs/guides/simple-profiling/">参考</a></p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">--prof</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">index.js</span></span></code></pre>
<p>このオプションをつけて起動しプロセスを終了すると <code>isolate-xxxxx-xxxx-v8.log</code> というファイルが吐き出されます。このファイルは人間が読み解くにはすこし難易度が高いので、さらにこのファイルを Node.js に食わせます。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">--prof-process</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">isolate-xxxxx-xxxx-v8.log</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">></span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">isolate.txt</span></span></code></pre>
<p>こうして吐き出された isolate.txt ファイルの中身を見てみます。</p>
<p>注目するべき場所は <code>[Summary]</code> です。ここは JavaScript や C++ レイヤーのコードがどれだけ CPU を専有しているかを表しています。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">[Summary]:</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">ticks</span><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">total</span><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">nonlib</span><span style="color: #E1E4E8">   </span><span style="color: #9ECBFF">name</span></span>
<span class="line"><span style="color: #E1E4E8">     </span><span style="color: #B392F0">0</span><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">0.2</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">0.2</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">JavaScript</span></span>
<span class="line"><span style="color: #E1E4E8">   </span><span style="color: #B392F0">114</span><span style="color: #E1E4E8">   </span><span style="color: #79B8FF">82.4</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">   </span><span style="color: #79B8FF">89.6</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">C++</span></span>
<span class="line"><span style="color: #E1E4E8">     </span><span style="color: #B392F0">3</span><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">2.2</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">2.4</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">GC</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">11</span><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">8.0</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">          </span><span style="color: #9ECBFF">Shared</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">libraries</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">13</span><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">9.4</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">          </span><span style="color: #9ECBFF">Unaccounted</span></span></code></pre>
<p>上記の例では C++ レイヤーの処理が全体の 80%を占めていることがわかります。つまり Node.js のコアコードが占める割合が多くあるということが読み取れます。</p>
<p>逆に JavaScript の割合が大きければ、アプリケーションにかかれている JavaScript 文法で書かれた部分が多くを占めるということになります。</p>
<p>コアコードの割合が大きかったら手を出せないじゃないかと思うかもしれませんが、これはアプリケーションコードやライブラリがコアコード（標準モジュール）を大量に呼び出していれば比率が高くなります。</p>
<p>例えば <code>fs.readFilesync</code> のような同期コードを呼ぶと、その処理中他の JavaScript コードは動くことができないので C++ の total 時間が加算されます。なのでコアコードだからといって改善できない訳ではありません。</p>
<p>GC はガベージコレクションが走ったことを表します。例えばここが <code>1453 6.0% 168.8% GC</code> のように大量に呼ばれていた場合「頻繁な GC が起きている」=「メモリリークが起きてしまっている可能性がある」と読み解けます。</p>
<p>他にも <code>Bottom up (heavy) profile</code> の欄を見ると具体的にどういった関数が重い処理なのかを確認することができます。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">[Bottom up (heavy) profile]:</span></span>
<span class="line"><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Note:</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">percentage</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">shows</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">a</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">share</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">of</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">a</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">particular</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">caller</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">in</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">the</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">total</span></span>
<span class="line"><span style="color: #E1E4E8"> </span><span style="color: #B392F0">amount</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">of</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">its</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">parent</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">calls.</span></span>
<span class="line"><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Callers</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">occupying</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">less</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">than</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1.0</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">are</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">not</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">shown.</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #B392F0">ticks</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">parent</span><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">name</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">78</span><span style="color: #E1E4E8">   </span><span style="color: #79B8FF">39.4</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">  </span><span style="color: #9ECBFF">T</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">__ZN2v88internal40Builtin_CallSitePrototypeGetPromiseIndexEiPmPNS0_7IsolateE</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">34</span><span style="color: #E1E4E8">   </span><span style="color: #79B8FF">43.6</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">    </span><span style="color: #9ECBFF">T</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">__ZN2v88internal40Builtin_CallSitePrototypeGetPromiseIndexEiPmPNS0_7IsolateE</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">18</span><span style="color: #E1E4E8">   </span><span style="color: #79B8FF">52.9</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">      </span><span style="color: #9ECBFF">LazyCompile:</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">~promise</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">/tmp/index.js:14:23</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">18</span><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">100.0</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">        </span><span style="color: #9ECBFF">T</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">__ZN2v88internal40Builtin_CallSitePrototypeGetPromiseIndexEiPmPNS0_7IsolateE</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">18</span><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">100.0</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">          </span><span style="color: #9ECBFF">t</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node::task_queue::RunMicrotasks</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">v8::FunctionCallbackInfo&#x3C;v8::Value></span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">const</span><span style="color: #E1E4E8">&#x26;)</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">18</span><span style="color: #E1E4E8">  </span><span style="color: #79B8FF">100.0</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">            </span><span style="color: #9ECBFF">LazyCompile:</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">~processTicksAndRejections</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">internal/process/task_queues.js:65:35</span></span>
<span class="line"><span style="color: #E1E4E8">     </span><span style="color: #B392F0">2</span><span style="color: #E1E4E8">    </span><span style="color: #79B8FF">5.9</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">      </span><span style="color: #9ECBFF">T</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">__ZN2v88internal40Builtin_CallSitePrototypeGetPromiseIndexEiPmPNS0_7IsolateE</span></span>
<span class="line"><span style="color: #E1E4E8">     </span><span style="color: #B392F0">1</span><span style="color: #E1E4E8">   </span><span style="color: #79B8FF">50.0</span><span style="color: #9ECBFF">%</span><span style="color: #E1E4E8">        </span><span style="color: #9ECBFF">t</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node::task_queue::RunMicrotasks</span><span style="color: #E1E4E8">(</span><span style="color: #B392F0">v8::FunctionCallbackInfo&#x3C;v8::Value></span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">const</span><span style="color: #E1E4E8">&#x26;)</span></span></code></pre>
<p>しかし、この文字列情報だけでは多少見やすいとはいえ具体的にどこがヘビーなポイントなのかを読み解くのは容易ではありません。</p>
<p>そこで自分は flamegraph を利用してこれらの可視化を行っています。</p>
<h3 id="flamegraph-編">flamegraph 編</h3>
<p>flamegraph は先にあげたコードパスの実行時間などをヒューマンフレンドリーに可視化してくれるツールです。これを通すことでホットコードなどが可視化され、どこを直すと効果が高いのかを見極めやすくなります。</p>
<p>flamegraph を表示するためのモジュールはいくつかありますが、自分は今は <a href="https://www.npmjs.com/package/0x">0x</a> というモジュールを利用しています。
これは Node.js のコアコミッターが作成しているモジュールなので、今後のバージョンアップにも追従していくだろうという予想から採用しています。</p>
<p>このモジュールをパフォーマンス検証環境にグローバルインストールします。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">npm</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">i</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-g</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #9ECBFF">x</span></span></code></pre>
<p>インストールがすんだら 0x コマンド経由で Node.js を起動します。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #9ECBFF">x</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">--</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">index.js</span></span></code></pre>
<p>そして起動した環境に vegeta で負荷をしばらくかけてから一度プロセスを終了します。</p>
<p>そうすると <code>4123.0x/</code> のようなディレクトリが生成されます。この中には先の <code>--prof</code> オプションで吐き出しされた <code>isolate-xxxxx-xxxx-v8.log</code> や <code>flamegraph.html</code> というファイルが格納されています。</p>
<p>今回注目するのは <code>flamegraph.html</code> です。これをブラウザで開くと次の画像のようなページが見られます。</p>
<p><img src="/img/2020-03-04-nodejs-performance/flamegraph.png" alt="flamegraph"></p>
<p>これは先程 <code>--prof-process</code> で吐き出した結果をよりグラフィカルに表したようなものです。濃い赤色になっているほどホットコード = 一番多く通るコードパスです。つまりこの濃い赤色の部分のパフォーマンスを向上させられると、全体に効果が出やすいわけです。</p>
<p>横軸は関数の実行時間を表し、その関数が呼び出した関数が上に積み上げられていきます。最初は縦に大量に積み上がっているとびっくりすることもあるかと思いますが、気にするべきは横幅です。「縦に積み上がっていて横幅が短い」のは「たくさん関数を呼び出しているが実行時間は短い」という意味になります。</p>
<p>なので最初は横幅が長くて、ホットコードな部分を重点的にみていくとよいと思います。</p>
<p>上の flamegraph は下のサンプルコードの結果です。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">path</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'path'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">fs</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'fs'</span><span style="color: #E1E4E8">).promises</span></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">express</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'express'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">app</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">express</span><span style="color: #E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">app.</span><span style="color: #B392F0">get</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'/'</span><span style="color: #E1E4E8">, </span><span style="color: #F97583">async</span><span style="color: #E1E4E8"> (</span><span style="color: #FFAB70">req</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">res</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">next</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">try</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">html</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">await</span><span style="color: #E1E4E8"> fs.</span><span style="color: #B392F0">readFile</span><span style="color: #E1E4E8">(path.</span><span style="color: #B392F0">join</span><span style="color: #E1E4E8">(__dirname, </span><span style="color: #9ECBFF">'index.html'</span><span style="color: #E1E4E8">), {</span></span>
<span class="line"><span style="color: #E1E4E8">      encode: </span><span style="color: #9ECBFF">'utf8'</span></span>
<span class="line"><span style="color: #E1E4E8">    })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">    res.</span><span style="color: #B392F0">status</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">200</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">send</span><span style="color: #E1E4E8">(html)</span></span>
<span class="line"><span style="color: #E1E4E8">  } </span><span style="color: #F97583">catch</span><span style="color: #E1E4E8"> (e) {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #B392F0">next</span><span style="color: #E1E4E8">(e)</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">app.</span><span style="color: #B392F0">listen</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">8000</span><span style="color: #E1E4E8">, () </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'listen'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span></code></pre>
<p>flamegraph で一番赤くなっているとなっている部分をみると <code>~readFileHandle internal/fs/promises.js</code> となっています。つまり fs モジュールの readFile という処理が多く動いているということがわかります。</p>
<p>上記のサンプルコードでいうとリクエストのたびに <code>fs.readFile</code> が走ってしまうためホットコードとして現れています。</p>
<p>この場合はリクエストによって返すファイルは変わらないので、サーバ起動時に一度だけファイルを読み込むようにすれば先程のようなホットコードの表示にはならないでしょう。</p>
<p>実際にはこんな単純に見つけられることはあまりないですが、俯瞰して眺めるのに利用します。まれに同期コードがホットコードして現れて一気に改善できることもあるので、右上にある検索ボックスにまず <code>Sync</code> と入れて検索をしたりします。</p>
<h1 id="3-具体的なパフォーマンスイシュー編">3. 具体的なパフォーマンスイシュー編</h1>
<p>パフォーマンスイシューはアプリケーションごとに異なる特有のコードなことが多いので、あまりこれといったパターンを示せないことが多いです。</p>
<p>とはいえ、自分が絶対に気をつけてみている観点はいくつかあります。<a href="https://speakerdeck.com/ajido/minimum-handson-nodejs?slide=18">こちらの資料</a>に非常に詳しくまとまっていますが、これだけはどのアプリケーションでもパフォーマンスを下げてしまいがちな気をつけるべきポイントです。</p>
<ul>
<li>巨大な JSON を扱う（JSON.parse/JSON.stringiy）</li>
<li>同期関数を使う（fs.readFileSync）</li>
<li>長いループが回っている</li>
</ul>
<p>上記の処理に共通するのは「同期処理」です。Node.js では IO（ネットワークやファイル）に関わらない処理は基本的に同期処理となり CPU を専有します。</p>
<p>なので IO を伴わない処理をなるべく短くしていき「同期処理」を「細切れになるように」構築していくのがパフォーマンスを劣化させないコツになってきます。</p>
<p>それぞれ具体的に解説していきます。</p>
<h2 id="巨大な-json-を扱う">巨大な JSON を扱う</h2>
<p>JSON.parse/JSON.stringify は同期処理です。Node.js の同期処理はサーバのリソースをそれのみに集中してしまうため、その処理中は他のリクエストを捌くことはできません。</p>
<p>JSON の処理は JSON の大きさに比例して停止時間が長くなります。これは特に SSR/BFF などのサーバでボトルネックになりがちです。</p>
<p>例えば React の SSR であれば最後に state オブジェクトを文字列化して html に渡しますが、ここの JSON が大きければもちろんサーバの停止時間は長くなります。</p>
<p>これを解消するためには、そのページで同期的にレンダリングしなくてもよい箇所はブラウザに任せて非同期に描画し、不要な state を外してレンダリングに必要な JSON を小さくします。</p>
<p>他にもバックエンドの API を叩いて SSR を行うというのはよくあるケースだと思いますが、この際にバックエンドから返却される JSON が大きく、リクエストのたびに JSON.parse が走りその都度サーバがストップしてしまっていることがよくあります。</p>
<p>自分では JSON.parse を書いているつもりはなくても axios などのリクエストモジュールを利用しているとモジュール内部で JSON.parse が行われていたりします。</p>
<p>この影響を少なくするためには基本的に JSON を小さくするか JSON.parse 自体の数を減らすしかありません。</p>
<ul>
<li>なるべくキャッシュして JSON.parse が起きないようにする</li>
<li>エントリポイントを分割して 1 つずつを小さくする（ページングや ID だけの配列からリクエストを分割して叩くように設計するなど）</li>
</ul>
<p>どれくらいの大きさから大きいというのかは難しい問題ですが、目安としては「最大でも 1MB 以内」に収まるあたりがよいと思います。</p>
<p>また、API を作成した時点では小さい JSON だったけど、データ量が増えるにつれて比例して肥大化していった（配列でデータを返しているパターンが多い）ということもあるので、API 設計時点で将来も肥大化しない設計であることは重要です。</p>
<p>Node.js v12 で JSON.parse はかなり高速化していますが、それでも気をつけるべきなのは間違いありません。</p>
<h2 id="同期関数を使う">同期関数を使う</h2>
<p>こちらも理屈は JSON と同じで、同期処理中は他のリクエストを捌けないため、リクエストのたびに通るコードパスからはなるべく避ける必要があります。</p>
<p>~Sync とついていたら危ないかも？と思っておくとよいかもしれません。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">fs</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'fs'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">app.</span><span style="color: #B392F0">get</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'/'</span><span style="color: #E1E4E8">, (</span><span style="color: #FFAB70">req</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">res</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// ここでサーバがストップする</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">html</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> fs.</span><span style="color: #B392F0">readFileSync</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'./index.html'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">  res.</span><span style="color: #B392F0">status</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">200</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">send</span><span style="color: #E1E4E8">(html)</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span></code></pre>
<p>もちろん絶対に使ってはいけないというわけではなく、リクエストのたびに通らないコードパスであれば問題ありません。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">fs</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'fs'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D">// ここでサーバがストップするが、サーバ起動時に一度だけしか動かないので問題ない</span></span>
<span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">html</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> fs.</span><span style="color: #B392F0">readFileSync</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'./index.html'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">app.</span><span style="color: #B392F0">get</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'/'</span><span style="color: #E1E4E8">, (</span><span style="color: #FFAB70">req</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">res</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  res.</span><span style="color: #B392F0">status</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">200</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">send</span><span style="color: #E1E4E8">(html)</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span></code></pre>
<p>どうしてもリクエストのたびに通るパスで使いたい、というときは基本的には非同期処理の関数が用意されているはずなのでそちらを利用しましょう。</p>
<p>Node.js のコアモジュールは callback 形式になっていることが多いですが、最近は Promise のインターフェースも生えています。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">fs</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'fs'</span><span style="color: #E1E4E8">).promises</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">app.</span><span style="color: #B392F0">get</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'/'</span><span style="color: #E1E4E8">, (</span><span style="color: #FFAB70">req</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">res</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  fs.</span><span style="color: #B392F0">readFile</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'./index.html'</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">then</span><span style="color: #E1E4E8">((</span><span style="color: #FFAB70">html</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    res.</span><span style="color: #B392F0">status</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">200</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">send</span><span style="color: #E1E4E8">(html)</span></span>
<span class="line"><span style="color: #E1E4E8">  })</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span></code></pre>
<h2 id="長いループが回っている">長いループが回っている</h2>
<p>これも先の例と同様に同期処理です。長い配列をループで回している間はサーバが停止します。ループは先の例に比べて避けるのが難しい処理でが、緩和する方法はいくつかあります。</p>
<p>例えば１万件のデータが入っている Redis の key を取得して、それぞれに処理を行い返すようなエンドポイントがあったとします。（API 設計の時点でページングしたほうがよいのは確かですが例として）</p>
<p>下記のようなコードだと、レスポンスを返す直前にループ処理をしてしまうので、その間リクエストを受けることができません。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">redis</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Redis</span><span style="color: #E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">app.</span><span style="color: #B392F0">get</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'/'</span><span style="color: #E1E4E8">, (</span><span style="color: #FFAB70">req</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">res</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">keys</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> []</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// データを100件ずつ取得する stream を作る</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">stream</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> redis.</span><span style="color: #B392F0">scanStream</span><span style="color: #E1E4E8">({ count: </span><span style="color: #79B8FF">100</span><span style="color: #E1E4E8"> })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 100件取得したら keys に詰め込む</span></span>
<span class="line"><span style="color: #E1E4E8">  stream.</span><span style="color: #B392F0">on</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'data'</span><span style="color: #E1E4E8">, (</span><span style="color: #FFAB70">results</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">; i </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> results.</span><span style="color: #79B8FF">length</span><span style="color: #E1E4E8">; i</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      keys.</span><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(results[i])</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  stream.</span><span style="color: #B392F0">on</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'end'</span><span style="color: #E1E4E8">, () </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// keys.map が1万件のループになるので長時間の停止になってしまう</span></span>
<span class="line"><span style="color: #E1E4E8">    res.</span><span style="color: #B392F0">status</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">200</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">json</span><span style="color: #E1E4E8">(keys.</span><span style="color: #B392F0">map</span><span style="color: #E1E4E8">((</span><span style="color: #FFAB70">e</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">`key-${</span><span style="color: #E1E4E8">e</span><span style="color: #9ECBFF">}`</span><span style="color: #E1E4E8">))</span></span>
<span class="line"><span style="color: #E1E4E8">  })</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span></code></pre>
<p>例えばこの場合は data イベントの中で整形処理をするべきです。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">redis</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">new</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Redis</span><span style="color: #E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">app.</span><span style="color: #B392F0">get</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'/'</span><span style="color: #E1E4E8">, (</span><span style="color: #FFAB70">req</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">res</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">keys</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> []</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// データを100件ずつ取得する stream を作る</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">stream</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> redis.</span><span style="color: #B392F0">scanStream</span><span style="color: #E1E4E8">({ count: </span><span style="color: #79B8FF">100</span><span style="color: #E1E4E8"> })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #6A737D">// 100件取得したら keys に詰め込む</span></span>
<span class="line"><span style="color: #E1E4E8">  stream.</span><span style="color: #B392F0">on</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'data'</span><span style="color: #E1E4E8">, (</span><span style="color: #FFAB70">results</span><span style="color: #E1E4E8">) </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">for</span><span style="color: #E1E4E8"> (</span><span style="color: #F97583">let</span><span style="color: #E1E4E8"> i </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">0</span><span style="color: #E1E4E8">; i </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> results.</span><span style="color: #79B8FF">length</span><span style="color: #E1E4E8">; i</span><span style="color: #F97583">++</span><span style="color: #E1E4E8">) {</span></span>
<span class="line"><span style="color: #E1E4E8">      keys.</span><span style="color: #B392F0">push</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">`key-${</span><span style="color: #E1E4E8">results</span><span style="color: #9ECBFF">[</span><span style="color: #E1E4E8">i</span><span style="color: #9ECBFF">]</span><span style="color: #9ECBFF">}`</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">    }</span></span>
<span class="line"><span style="color: #E1E4E8">  })</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">  stream.</span><span style="color: #B392F0">on</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'end'</span><span style="color: #E1E4E8">, () </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #6A737D">// 整形が終わっているのでループは回らない</span></span>
<span class="line"><span style="color: #E1E4E8">    res.</span><span style="color: #B392F0">status</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">200</span><span style="color: #E1E4E8">).</span><span style="color: #B392F0">json</span><span style="color: #E1E4E8">(keys)</span></span>
<span class="line"><span style="color: #E1E4E8">  })</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span></code></pre>
<p>このように、大量のループを回さなければならない場合でも、間に IO を挟むことで細切れにできる可能性があります。</p>
<p>Stream 処理は難しいと思われがちですが、大量の処理を省メモリで行うのに適したデザインパターンなので覚えておいて損はありません。</p>
<p>特に Node.js v12 では AsyncIterator も Stable になっているので記述がしやすくなっています。</p>
<p>Stream については過去に記事を書いたので、そちらをご参照ください。<a href="https://qiita.com/koh110/items/0fba3acbce38916928f1">さよなら Stream</a></p>
<h1 id="4-メモリリーク調査編">4. メモリリーク調査編</h1>
<p>前項で述べてきたパフォーマンスチューニングは主に設計やアプリケーションの書き方によるパフォーマンス低下をみつける手法でした。</p>
<p>Node.js が性能を劣化させる原因のもうひとつにガベージコレクションがあります。基本的に他の言語と同様にガベージコレクションはランタイムを停止させてしまうため、性能上よくありません。</p>
<p>プロファイリングの項で少し触れましたが、プロファイリングからガベージコレクションがどれくらいの頻度で走っているかを取得することができます。</p>
<p>ガベージコレクションが大量に起きていたり、もしくはサーバの監視で右肩上がりをしていたメモリ使用量が突然下がってまた上昇していく、といった特徴が出ていた場合、コード中にメモリリークしているコードが含まれている可能性があります。</p>
<p>基本的に Node.js のコアコードにメモリリークは存在しません。メモリリークが起きてしまっているということはほぼ確実に「自分の書いたコード」か「利用しているモジュール」に原因があります。</p>
<p>ここでは実際に自分が体験した <a href="https://material-ui.com/">material-ui</a> の使い方で起きていたメモリリークの例をもとに、調査の方法をまとめたいと思います。</p>
<h2 id="リークが起きていることを確認">リークが起きていることを確認</h2>
<p>実際にメモリリークが起きているかを確認するためには、やはり計測してみるしかありません。次のようなコードを差し込んでみます。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">setInterval</span><span style="color: #E1E4E8">(() </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">try</span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">    global.</span><span style="color: #B392F0">gc</span><span style="color: #E1E4E8">()</span></span>
<span class="line"><span style="color: #E1E4E8">  } </span><span style="color: #F97583">catch</span><span style="color: #E1E4E8"> (e) {</span></span>
<span class="line"><span style="color: #E1E4E8">    console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'use --expose-gc'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">    process.</span><span style="color: #B392F0">exit</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">  }</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">const</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">heapUsed</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> process.</span><span style="color: #B392F0">memoryUsage</span><span style="color: #E1E4E8">().heapUsed</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'Heap:'</span><span style="color: #E1E4E8">, heapUsed, </span><span style="color: #9ECBFF">'bytes'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">}, </span><span style="color: #79B8FF">2000</span><span style="color: #E1E4E8">)</span></span></code></pre>
<p><code>global.gc</code> は強制的に GC を呼び出す関数です。heap メモリの使用量を出力する前に GC を走らせてもメモリ使用量が上がり続けていれば GC できない領域にメモリを掴み続けている（メモリリークがある）可能性があります。</p>
<p>この関数を利用するためにはフラグ付きで起動する必要があります。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">node</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">--expose-gc</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">index.js</span></span></code></pre>
<p>実際にメモリリークが起きているサーバで起動してみると、右肩上がりにヒープが使われていくのがわかります。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">137273608</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">144623352</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">146617720</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">146791344</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">146827544</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">146838568</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">146988200</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">131588016</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">213734336</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">338640232</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">471909552</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">394506192</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">515059296</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">617747056</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">720730040</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">821192400</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">924329760</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">957664088</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">957814288</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">957840840</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span>
<span class="line"><span style="color: #B392F0">Heap:</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">957848128</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">bytes</span></span></code></pre>
<p>もちろん普通のアプリケーションも時間経過とともにメモリ消費は増えるものなので、右肩上がりだからといって即座にメモリリークと判断するのは危険です。先に述べたような特徴と合わせて事前にメモリリークが起きているかどうかを判断しましょう。</p>
<p>しかしこれだけでは具体的に何がメモリリークを起こしているのかはわかりません。</p>
<p>なので、次はメモリのヒープダンプをとります。</p>
<h2 id="ヒープダンプの取得">ヒープダンプの取得</h2>
<p>Node.js でメモリを直接調査する方法はくつか方法がありますが <a href="https://www.npmjs.com/package/heapdump">heapdump</a> モジュールを使う方法が手軽です。</p>
<p>少し昔の記事ですが、こちらで紹介されている<a href="https://postd.cc/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/">メモリリークの発見ガイド</a>は非常に参考になるので必読です。</p>
<p>基本的に行うことは上記の記事にある「３点ヒープダンプ法」です。</p>
<p>自分は下記のようなコードを差し込み外から kill コマンドを送って３回ヒープダンプを取得します。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">require</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'heapdump'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">process.</span><span style="color: #B392F0">on</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'SIGUSR2'</span><span style="color: #E1E4E8">, () </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> {</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'heap dump start!'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">  heapdump.</span><span style="color: #B392F0">writeSnapshot</span><span style="color: #E1E4E8">()</span></span>
<span class="line"><span style="color: #E1E4E8">  console.</span><span style="color: #B392F0">log</span><span style="color: #E1E4E8">(</span><span style="color: #9ECBFF">'heap dump end!'</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">})</span></span></code></pre>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #B392F0">$</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">kill</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">-USR2</span><span style="color: #E1E4E8"> </span><span style="color: #9ECBFF">{{pid}}</span></span></code></pre>
<p>このとき <code>SIGUSR1</code> を割り当てないのには理由があります。</p>
<p><code>SIGUSR1</code> は Linux 的にはユーザーが自由に使っていいシグナルになっていますが、Node.js では debugger を起動するシグナルとして利用されています。<a href="https://nodejs.org/api/process.html#process_signal_events">詳細</a></p>
<p>イベントにハンドラーをバインドすることはできますが debugger が起動してしまうので避けたほうがいいでしょう。</p>
<p>話は戻って heapdump モジュールを利用して <code>heapdump.writeSnapshot()</code> を実行すると <code>heapdump-xxxx</code> というファイルが取得できます。</p>
<p>次に Chrome の開発者ツールを開き Profiles タブを開いて Load ボタンからファイルをロードしていきます。</p>
<p>下の図が実際に調査を行ったときのスクリーンショットです。</p>
<p><img src="/img/2020-03-04-nodejs-performance/memory.png" alt="メモリリーク調査"></p>
<p>先の記事で解説されている３点ヒープダンプ法は <code>All objects</code> となっているところから <code>Objects allocated between heapdump-xxx and heapdump-</code> を選択して、 heapdump 間で新しくアロケートされメモリの上に GC されずに残ってしまっているオブジェクトを探すことで、どのオブジェクトがメモリリークを起こしているのかを知る方法です。</p>
<p>しかし、今回の計測の結果では３点ヒープダンプ方を使ってメモリリークを見つけることはできませんでした。</p>
<p>ではどこに注目したかというと <code>(string)</code> という表記です。</p>
<p>先の記事では「少なくとも最初は<code>(string)</code>を無視する」と書いてありますが、今回調査していたサーバは SSR の機能を担うだったことと、明らかに他のオブジェクトに比べて大きなメモリを消費していたので気になりました。</p>
<p><code>(string)</code> の左にある三角を押すと実際に参照している関数やオブジェクトなどが展開されます。実際に追ってみると大量の <code>StyleSheet</code> というオブジェクトが <code>(string)</code> を参照していることがわかりました。実際にメモリの中身を覗いてみると、ほぼ style の文字列情報でした。</p>
<p>ということでスタイル系の処理がリクエスト終了後も文字列を掴み続けてしまっているのではないかと当たりをつけて、先程のオブジェクトがどこで生成されているかを調べてみると material-ui が生成していることがわかりました。</p>
<p>さらに <code>StyleSheet memory leak</code> で issue を調べてみると次の <a href="https://github.com/mui-org/material-ui/issues/10927">issue</a> で同じ現象になっている人をみつけました。</p>
<p>issue 内のコードと実コードを見比べてみると sheetsManager という props を渡していないことがわかり、これを加えることでメモリリークは解消しました。</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #E1E4E8">  &#x3C;StylesProvider</span></span>
<span class="line"><span style="color: #E1E4E8">    sheetsRegistry={registry}</span></span>
<span class="line"><span style="color: #E1E4E8">    generateClassName={generateClassName}</span></span>
<span class="line"><span style="color: #85E89D"><span style="user-select: none;">+</span>   sheetsManager={new Map()}</span></span>
<span class="line"><span style="color: #E1E4E8">  ></span></span></code></pre>
<p>（蛇足ですが、ドキュメントにそんな記載があったかなと探しては見ましたが、うまく記述が見つけられませんでした。確かに<a href="https://github.com/mui-org/material-ui/blob/bdebdfd4832c13a05463faeffef9687688be9715/packages/material-ui-styles/src/StylesProvider/StylesProvider.js#L43-L49">コード</a>を眺めてみると、<code>NODE_ENV=production</code>以外の時に sheetsManager が与えられていないと警告のログが出るようになっていましたが、今回のケースでは本番環境相当で起動していたため気づけませんでした。）</p>
<p>このようにヒープダンプを追っていくことで、原因の特定に役立つことがあります。</p>
<h1 id="まとめ">まとめ</h1>
<p>自分が Node.js のパフォーマンスチューニングでいつも見ている点や方法をまとめました。</p>
<p>パフォーマンスイシューはアプリケーションによって異なるため、地道な計測と調査が必要になりますが、やった数だけ確実に勘所がつくようになります。</p>
<p>自分もいくつかの環境を見ることである程度勘が働くようになってはきましたが、まだまだたくさんの事例をみないといけないなと毎回思います。</p>
<p>Twitter などで声をかけていただければ、実際のアプリケーションコードを見ながら調査のお手伝い等もできるので、ぜひ一緒に知見をためましょう！</p>
</article>

    <hr class="astro-5GRSW2HI">
    <ul class="post-selector astro-5GRSW2HI">
     <li class="astro-5GRSW2HI"><a rel="prev" href="/2020-01-01-vpn" class="astro-5GRSW2HI"> ← WireGuardでVPNごしに自宅サーバ開発できる環境を作った</a></li>
     <li class="astro-5GRSW2HI"><a rel="next" href="/2020-05-13-async-iterator" class="astro-5GRSW2HI">AsyncIteratorと落とし穴 → </a></li>
    </ul>
    <footer class="astro-SZ7XMLTE">
  © 2023,
  <a href="https://koh.dev" target="_blank" class="astro-SZ7XMLTE">
    kohsweb
  </a>
</footer>
  </main>

  <script src="https://b.st-hatena.com/js/bookmark_button.js" type="text/javascript" async></script>
</body></html>